//---------------------------------------------------------------------------
// PilotMAG Main
//
//
//                                                    (c) John Smith 01/01/99
//---------------------------------------------------------------------------
// This file is only start up code, it is not generated by PilotMAG.
// You can edit this file by your self, to made your own start up file.
// Originally located at: c:\Programs Files\Monte Soft\PilotMAG\PilotMAG.ptr
//---------------------------------------------------------------------------

// Main Include file for SDK 3.5
#include <PalmOS.h>
#include <PalmCompatibility.h>
#include	<DLServer.h>			//	Needed for DlkGetSyncInfo

#include "MarblesSq.h"
#include "grid.h"


#define ctrlPtr(frm,id) (FrmGetObjectPtr (frm, FrmGetObjectIndex (frm, id)))

#undef BLOCK_MOVE_DEBUG

// misc - it's for the different colour modes
#define SCREEN_MODE 4

// we'll only store 3 high scores
#define highScoreMax  9 // 10 - doesn't fix on the box :(
#define nameLengthMax 15

// High Scores settings
#define highScoreFont				stdFont
#define firstHighScoreY				28
#define highScoreHeight				12
#define highScoreNameColumnX		17
#define highScoreScoreColumnX		114		// Right aligned
#define highScoreLevelColumnX		153		// Right aligned

#define appFileCreator				'MarB'
#define appPrefID					0
#define appPrefVersion				1
#define appGameStatePrefVersion     2  // holds any updates to the game type
#define appGridPrefVersion     		2  // holds any updates to the game type

#define version35					0x03503000
#define version30                   0x03003000

#define gtSingleBasic 0
#define gtSingleRotation 1
#define gtMultiSame 2

#define player1 0
#define player2 1

// Game Options
#define gsScoreTimeout 1
#define gsSound 2
#define gsDblTap 4

// Sound
#define HighBeep 1
#define LowBeep 2
#define HighSweepLow 3
#define LowSweepHigh 4

// this is the same as the 'firstUserEvent' in the event enum
#define appRealStopEvent 0x6000

WinHandle screenBufferH;
Int16 col_lengths[9];
Boolean gotVersion35 = false;

const CustomPatternType	white	= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
const CustomPatternType	black	= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

struct {
    Int16  selected;
    Int16  x;
    Int16  y;
} SelectedBlock;

typedef struct {
    Boolean game_active;
    Boolean undo_allowed;
    UInt8 remaining_blocks;             //  <-- possible reserved values
	UInt16 possible_score;
    Int32 score;
    UInt32 flags;                       // was...game_start_time; - now is sound, double tap and timeout
    UInt8 selected_blocks;
    UInt16 game_type;
    UInt8 current_player;  // starts at zero
    UInt16 current_level;
    UInt32 last_random_seed;
} GameStateType;

GameStateType GameState;

typedef struct {
	UInt8                   found_sets[6];
	/*
        The found_sets doesn't actually represent the number of sets found
        but those sets found under the following categories:
        2s, 3s, 4s, 5-9s, 10-20s, >20s
    */
    UInt8                   best_set;
    Int32                   score;
    UInt32                  game_length;
} PlayerState;

typedef struct
	{
	Char					name[nameLengthMax + 1];
	UInt16					flags;         // low 4 bits for level (up to 255) - upper for 8 flags (0x100->0x800)
    UInt16					score;         // note - split Int32 in to 2xUInt32
	} SavedScore;

typedef struct
	{
	SavedScore				high_score[highScoreMax];
	Byte					last_high_score;
	UInt32					last_high_score_seed;	// level is held in the SavedScore.flags
	} MarblePreferenceType;

MarblePreferenceType			Prefs;


// can this be done using memhandles?
PlayerState player[2];

// internal game settings
Int32 last_possible_score;

// used to automatically hide the score box
Boolean gScoreDisplayed;
UInt32  gScoreDisplayTime;
//UInt32  gLastRandomSeed;
UInt16  GameVolume;             // volume from preferences

//Byte * gtUndo[10][12];

static int StartApplication(void);
static void EventLoop(void);
static void StopApplication(void);
static Boolean frmMainEventH(EventPtr event);
static Boolean frmOptionsEventH(EventPtr event);
static void DrawGrid(Boolean update_only);
static void DrawObject(Int bitmapNumber, Short x, Short y, ScrOperation mode);
void DrawPoint(UInt16 x, UInt16 y);
static void MoveDeadBlockToTop(Int32 x, Int32 y, UInt16 col_length);
static void RemoveMarkedBlocks(void);
void UnMarkAllBlocks(void);
static void LockImage(int i, DmResID resId);
static void ReleaseLockedImage(int i);
static Boolean CheckForBlankColumns(void);
static void ShiftRowLeft(Int16 start_x, Int16 y);
static void FindPossibleSets(void);
static void CheckGameState(void);
static void InitGame(Boolean keep_score);
static Boolean HighScoresCheckScore (Long score);
void HighScoresDisplay (void);
Boolean SetVideoMode(void);
void RestoreVideoMode(void);
void ShowScore(Int32 score, CharPtr prefix_str);
void ClearHighScores(Int16 start_from);
void UndoMove(void);
void GetSyncName(CharPtr nameP);
static UInt16 FindMarkedColumnLength(Int32 x, Int32 y);
void SendHighScores(void);
UInt32 GetCheckSum(CharPtr text);
void ShowMultiGameBreakDown(void);
FontID GetWinnersFont(Int16 val_p1, Int16 val_p2, UInt8 current_player);
static void EndGameMessage(void);
void ResetMultiPlayerScores(void);
void NewTwoPlayerGame(UInt8 current_player, UInt32 seed);
void NewOnePlayerGame(Boolean resume, UInt32 seed);
void NewGame(UInt8 current_player, Boolean resume, UInt32 seed);
void NewSeededGame(UInt32 seed);
UInt32 hex2bin(const char *hex);
UInt32 GetGameSeed(void);
void SoundEffect(Int16 effect);
Boolean GetCtrlValue(UInt16 objectID);
static void SelectBlocks(Int32 x, Int32 y);


//---------------------------------------------------------------------------
DWord  PilotMain (Word cmd, Ptr cmdPBP, Word launchFlags)
{
int error;

if (cmd == sysAppLaunchCmdNormalLaunch)
	{
    //// Set the screen mode
    SetVideoMode();

	error = StartApplication();	// Application start code
	if (error)
	    return error;
	EventLoop();	            	// Event loop
    RestoreVideoMode();
	StopApplication ();	        // Application stop code
	}
	return 0;
}

Boolean SetVideoMode(void)
{
    Err err;
    Boolean EnableColour;
    UInt32 screenDepth;

    // so we have support for all versions :)
	//if (gotVersion35)
    	WinScreenMode(winScreenModeGetSupportsColor, NULL, NULL, NULL, &EnableColour);
    //else
    //	ScrDisplayMode (ScrDisplayModeOperation operation, NULL, NULL, NULL, &EnableColour);

    // if colour enabled then we know we can do 8bit colours - otherwise
    // try 4 bit (grey) then just do black and white
    if (EnableColour)
    {
        screenDepth = 8;  // changed from 0x8000

		//if (gotVersion35)
		    err = WinScreenMode(winScreenModeSet, NULL, NULL, &screenDepth, &EnableColour);
        //else
        //    err = ScrDisplayMode(scrDisplayModeSet, NULL, NULL, 8, &EnableColor);
    }
    else
    {
        screenDepth = 4;
        //if (gotVersion35)


		    err = WinScreenMode(winScreenModeSet, NULL, NULL, &screenDepth, &EnableColour);
        //else
        //    err = ScrDisplayMode(scrDisplayModeSet, NULL, NULL, 4, false);

        if (err)
        {
	        screenDepth = 1;



			//if (gotVersion35)
			    err = WinScreenMode(winScreenModeSet, NULL, NULL, &screenDepth, &EnableColour);
	        //else
	        //    err = ScrDisplayMode(scrDisplayModeSet, NULL, NULL, 1, false);
        }
    }

    return false;
}

void RestoreVideoMode(void)
{
 	WinScreenMode(winScreenModeSetToDefaults, NULL, NULL, NULL, NULL);
}



//---------------------------------------------------------------------------
static int StartApplication(void)
{
	WinHandle oldDrawWinH;
    int i;
    Word error;
    RectangleType bounds;
    Int16 prefsSize;
    UInt32 romVersion;
    GameStateType gs;
    SoundLevelTypeV20 V2GameVolume;


    FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);

	// determine game volume level for sound
	if (romVersion >=  version30)
	{
		GameVolume = PrefGetPreference (prefGameSoundVolume);
	}
	else
	{
		V2GameVolume = PrefGetPreference (prefGameSoundLevelV20);
		if (V2GameVolume == slOff)
		{           // no sound wanted for games
			GameVolume = 0;
		}
		else
		{
			GameVolume = sndMaxAmp;             // they want sound
		}
	}

	if (romVersion >= version35)
		gotVersion35 = true;

    // Keep the Object graphics locked because they are frequently used
	oldDrawWinH = WinGetDrawWindow();

    // IMPORTANT: the +1 handles the dead block (ie. blank)
	for (i = 1; i <= NUM_BALLS; i++)
	{
        LockImage(i, bmp0+i);
	}

    /* add by hand the dead block and the mask */
    LockImage(DEAD_BLOCK, bmpDead);
    LockImage(MASK_BLOCK, bmpMask);

	screenBufferH = WinCreateOffscreenWindow (screenWidth, screenHeight, screenFormat, &error);
	WinSetDrawWindow(screenBufferH);
	bounds.topLeft.x = 0;
	bounds.topLeft.y = 0;
	bounds.extent.x = screenWidth;
	bounds.extent.y = screenHeight;
	WinEraseRectangle(&bounds, 0);

	WinSetDrawWindow(oldDrawWinH);


    // if there are no prefs - then this is the first time run
    // therefore - show the instructions
    // BUT we're also going to check the size matches our size,
    // this check will work out if this is a new version or not
	prefsSize = sizeof (GameStateType);
    if (PrefGetAppPreferences (appFileCreator, appPrefID+1, &gs, &prefsSize, true) == appGameStatePrefVersion)
    {
        MemMove(&GameState, &gs, sizeof(GameStateType));
    }
    else
    {
        GameState.game_active = false;
        GameState.flags = (gsSound + gsDblTap + gsScoreTimeout);

        // Now display the about box and instructions.  This appears automatically
		// the first time the program is run.
		FrmHelp (InstructionsStr);
    }


    // load the high scores from the prefs
    prefsSize = sizeof (MarblePreferenceType);
	if (PrefGetAppPreferences (appFileCreator, appPrefID, &Prefs, &prefsSize, true) == noPreferenceFound)
	{
		// There aren't any preferences

		// Clear the high scores.
        ClearHighScores(NULL);

		// No time has been recorded.
		Prefs.last_high_score_seed = 0;
	}

    // load the grid for resume
	prefsSize = sizeof (grid);
    // hack - use the undo - and if it fails - the undo may be corrupted
	if (PrefGetAppPreferences (appFileCreator, appPrefID+2, &undo_grid, &prefsSize, true) == appGridPrefVersion)
    {
        MemMove(&grid, &undo_grid, sizeof(grid));
    }

    //GameState.game_start_time = TimGetSeconds();

	FrmGotoForm(frmMain);
	return 0;
}

//---------------------------------------------------------------------------
static void EventLoop(void)
{
short err;
int formID;
FormPtr form;
EventType event;

do
	{
	EvtGetEvent(&event, 200);

	if (SysHandleEvent(&event))
	    continue;
	if (MenuHandleEvent((void *)0, &event, &err))
	    continue;
	if (event.eType == frmLoadEvent)
		{
		formID = event.data.frmLoad.formID;
		form = FrmInitForm(formID);
		FrmSetActiveForm(form);
		switch (formID)
			{
			case frmMain:
				FrmSetEventHandler(form, (FormEventHandlerPtr) frmMainEventH);
				break;
			case frmGameOptions:
				FrmSetEventHandler(form, (FormEventHandlerPtr) frmOptionsEventH);
				break;
			}
		}
	FrmDispatchEvent(&event);
	}
	while(event.eType != appRealStopEvent); //appStopEvent);     // this is our custom clean up event
}

//---------------------------------------------------------------------------
static void StopApplication(void)
{
	int i;


	// Delete the screenBuffer
	WinDeleteWindow(screenBufferH, false);


	// Unlock and release the locked bitmaps
	for (i = 1; i <= NUM_BALLS; i++)
	{
        ReleaseLockedImage(i);
	}

    ReleaseLockedImage(DEAD_BLOCK);
    ReleaseLockedImage(MASK_BLOCK);

    //Prefs.accumulated_time += (TimGetSeconds() - GameState.game_start_time);

	PrefSetAppPreferences (appFileCreator, appPrefID, appPrefVersion, &Prefs, sizeof (Prefs), true);
    PrefSetAppPreferences (appFileCreator, appPrefID+1, appGameStatePrefVersion, &GameState, sizeof (GameState), true);
    PrefSetAppPreferences (appFileCreator, appPrefID+2, appGridPrefVersion, &grid, sizeof (grid), true);

FrmCloseAllForms();
}


//---------------------------------------------------------------------------
static Boolean frmOptionsEventH(EventPtr event)
{
FormPtr   form;
int       handled = 0;

switch (event->eType)
	{
    case frmOpenEvent:
		form = FrmGetActiveForm();
        FrmDrawForm(form);

        // set up check boxes
        CtlSetValue(ctrlPtr(form,chkSound), (GameState.flags & gsSound));
		CtlSetValue(ctrlPtr(form,chkDblTap), (GameState.flags & gsDblTap));
        CtlSetValue(ctrlPtr(form,chkTimeout), (GameState.flags & gsScoreTimeout));

		handled = 1;
		break;
	case ctlSelectEvent:
        if (event->data.ctlEnter.controlID == btnOptOk)
        {
            GameState.flags = 0;

            if (GetCtrlValue(chkSound))
                GameState.flags |= gsSound;
        	if (GetCtrlValue(chkDblTap))
                GameState.flags |= gsDblTap;
        	if (GetCtrlValue(chkTimeout))
                GameState.flags |= gsScoreTimeout;

            FrmReturnToForm(frmMain);

            handled = 1;
	        break;
		}
    }

    return handled;
}

//---------------------------------------------------------------------------
static Boolean frmMainEventH(EventPtr event)
{
FormPtr   form;
int       handled = 0;

switch (event->eType)
	{
    case appStopEvent:
        if ( (GameState.game_type == gtMultiSame) &&
			((GameState.game_active == true) || (GameState.current_player == player1)) )
        {
            if (FrmCustomAlert(altConfirm,
					"You are currently in a 2 player game - quitting will reset the game.\n\nAre you sure you want to exit?",
					NULL, NULL) == 0)
            {
                EventType stopEvent;
                stopEvent.eType = appRealStopEvent;

				//GameState.game_type = gtSingleBasic;
                GameState.game_active = false;

				EvtAddEventToQueue(&stopEvent);
			}
            else // they don't want to quit
            {

            }
        }
        else
        {
			EventType stopEvent;
        	stopEvent.eType = appRealStopEvent;
            EvtAddEventToQueue(&stopEvent);
        }
    case menuEvent:
        if (event->data.menu.itemID == mnuHelp)
        {
            FrmHelp(InstructionsStr);
        }
        if (event->data.menu.itemID == mnuHighScores)
        {
         	HighScoresDisplay();
        }
        if (event->data.menu.itemID == mnuAbout)
        {
            FrmHelp(strAbout);
		}
        if (event->data.menu.itemID == mnuNew)
        {
            NewOnePlayerGame(false,0);
        }
		if (event->data.menu.itemID == mnuNewTwoPlayer)
        {
            NewTwoPlayerGame(player1,0);
		}
        if (event->data.menu.itemID == mnuShowScores)
        {
            ShowScore(GameState.score, "Score:");
        }
        if (event->data.menu.itemID == mnuClearAllScores)
        {
        	if (FrmCustomAlert (altConfirm, "Do you want to remove all high scores?", NULL, NULL) == 0)
				ClearHighScores(NULL);
        }
        if (event->data.menu.itemID == mnuClearLowScores)
        {
            if (FrmCustomAlert (altConfirm, "Remove all but the first 3 high scores?", NULL, NULL) == 0)
	            ClearHighScores(3);
        }
        if (event->data.menu.itemID == mnuUndo)
        {
            MenuEraseStatus(NULL);  // this clears the popup command before we redraw
        	UndoMove();
        }
        if (event->data.menu.itemID == mnuSendHighScores)
        {
            SendHighScores();
        }
        if (event->data.menu.itemID == mnuReplayLastGame)
        {
            if (GameState.game_type != gtMultiSame)
            {
	            if (GameState.last_random_seed != NULL)
		            NewSeededGame(GameState.last_random_seed);
	            else
	                FrmCustomAlert(altGameState, "The replay feature cannot be used for you *very first* game for this version.", NULL, NULL);
            }
            else
            {
                FrmCustomAlert(altGameState, "The replay feature is not available during a 2 player game.", NULL, NULL);
            }
        }
        if (event->data.menu.itemID == mnuViewGameSeed)
        {
            Char code[10];
			VoidHand strH;
			VoidPtr strP;

            strH = MemHandleNew(sizeof(Char)*(50));
            strP = MemHandleLock(strH);

            StrCopy(strP, "This game's code is: ");
			StrIToH(code, GameState.last_random_seed);
            StrCat(strP, code);

			MemPtrUnlock(strP);
            FrmCustomAlert(altGameState, strP, NULL, NULL);
			MemHandleFree(strH);
        }
        if (event->data.menu.itemID == mnuGameOptions)
        {
            FrmPopupForm(frmGameOptions);
        }
        if (event->data.menu.itemID == mnuPlayGameSeed)
        {
	        // this isn't support in < 3.5
			if (gotVersion35)
		    {
            	Char seedCode[9];
                UInt32 iSeedCode;

		        FrmCustomResponseAlert(altGameState, "Please enter the grid seed code:", NULL, NULL, (CharPtr)(&seedCode), 9, NULL);
                iSeedCode = hex2bin(seedCode);
                NewSeededGame(iSeedCode);
            }
            else
            {
                FrmCustomAlert(altGameState, "Sorry - this feature is not available for Palm OS < 3.5", NULL, NULL);
            }
        }
        if (event->data.menu.itemID == mnuGameBreakdown)
		{
            //if ((GameState.game_active == false) && (GameState.game_type == gtMultiSame) && (GameState.current_player == 1))
				ShowMultiGameBreakDown();
            //else
            //    FrmCustomAlert(altGameState, "Game breakdown is only available after a 2 player game is complete.", NULL, NULL);
		}
        handled = 1;
        break;
	case frmOpenEvent:
		form = FrmGetActiveForm();
        FrmDrawForm(form);
		NewGame(player1,true,0);
		handled = 1;
		break;
    case frmUpdateEvent:
	    // redraw the grid too

	    DrawGrid(true);
        if (GameState.game_active == false)
	        EndGameMessage();

        // return true to say we have handled the event
        handled = 1;
        break;
	case penDownEvent:
        // The game is still running and we haven't just selected from the menu
		if (GameState.game_active == true) // && (MenuGetActiveMenu() == NULL))
			{
	            SelectedBlock.selected = true;
	            SelectedBlock.x = event->screenX;
	            SelectedBlock.y = event->screenY;
	            AlignPointsToBlock(&SelectedBlock.x, &SelectedBlock.y);
			}
		//handled = 1;
        break;
    case penUpEvent:
        // If a block has been selected and we're not coming from the menu (but that is based on the last clause
		if ((SelectedBlock.selected == true) && (GameState.game_active == true))
		{
            UInt16 x, y;
			SelectedBlock.selected = false;
            x = event->screenX;
            y = event->screenY;

            // ensure the tap is on a block and move the x and y to
            // a block index (ie. 146,4 == 6,0 - or something similar)
            if (AlignPointsToBlock(&x, &y))
            {
                // if this x,y is the same as what we selected - and the block isn't a dead block already
            	if ( (x == SelectedBlock.x) && (y == SelectedBlock.y) )
                {
                    // mark the blocks on the first tap if the user has the option set up.
                    if (!(GameState.flags & gsDblTap))  // if not double tap
                    {
                        SelectBlocks(x, y);
                    }

                    if (grid[y][x].attributes & BLOCK_MARKED) // we need to make the blocks go - because this is the second click
                    {
                        // Play the sound
                    	SoundEffect(HighBeep);

						// create a copy of the current grid to enable the undo feature
                        MemMove(&undo_grid, &grid, sizeof(grid));
                        GameState.undo_allowed = true;

                        // remove all those selected block sets and drop the
                        // the blocks above down - and redraw
                        RemoveMarkedBlocks();

                        // check if we now have any blank columns if so
                        // shift the blocks from the right to the left
                        CheckForBlankColumns();

                        // give them the score
                        GameState.score += GameState.possible_score;

                        // update the last possible score - for the undo
                        // to work properly
                        last_possible_score = GameState.possible_score;

                        // is the game over?
                        CheckGameState();

                        // maintain the two player game - if it's active
                        //if (GameState.game_type == gtMultiSame)
                        //{
                            player[GameState.current_player].score = GameState.score;

                            // the found sets is in ranges:
                            // 2s, 3s, 4s, 5-9s, 10-19s, >20s

                            if (GameState.selected_blocks < 5)
                            {
                                player[GameState.current_player].found_sets[GameState.selected_blocks-2]++;
                            }
                            else if (GameState.selected_blocks < 10)
                            {
                                player[GameState.current_player].found_sets[3]++;
                            }
                            else if (GameState.selected_blocks < 20)
                            {
                                player[GameState.current_player].found_sets[4]++;
                            }
                            else if (GameState.selected_blocks > 20)
                            {
                                player[GameState.current_player].found_sets[5]++;
                            }

                            // if we got a best sized set - let's stored that
                            if (GameState.selected_blocks > player[GameState.current_player].best_set)
                            	player[GameState.current_player].best_set = GameState.selected_blocks;


                            // if the game is over and this is the last player - then we should popup
                            // as results window....
                            if ((GameState.game_active == false) && (GameState.current_player == player2))
                            {
                                ShowMultiGameBreakDown();
                            }

                        //}

                        ShowScore(GameState.score, "Score:");
                    }
                    else
                    {
                        // show blocks as marked
                        SelectBlocks(x, y);
					}
                }
                else
                {
                    ShowScore(0, NULL);
                }
	    	}
		}
        else if (GameState.game_active == false)
        {
        	RectangleType rect;

            // if the user just tapped in the 'Start New Game' box
            // then start the new game up

        	// check location of tap
            rect.topLeft.x = ((screenWidth / 2) - (85/2));  // 70
		    rect.topLeft.y = 50;

	        // dimensions
		    rect.extent.x = 85; //70;
		    rect.extent.y = 35; //25;

            if (RctPtInRectangle(event->screenX, event->screenY, &rect))
                NewGame(GameState.current_player == player1 ? player2 : player1, false,0); // this works out the next player
        }

        handled = 1;
		break;

	// add the help icon - since no one ever thinks about the menu
	case menuCmdBarOpenEvent:
        MenuCmdBarAddButton (menuCmdBarOnRight, bmpRestart, menuCmdBarResultMenuItem, mnuReplayLastGame, NULL);
        MenuCmdBarAddButton (menuCmdBarOnRight, BarUndoBitmap, menuCmdBarResultMenuItem, mnuUndo, NULL);
        MenuCmdBarAddButton (menuCmdBarOnRight, BarInfoBitmap, menuCmdBarResultMenuItem, mnuHelp, NULL);
		break;
	//	handled = true;

	case nilEvent:

	    if (MenuGetActiveMenu() == NULL)
			if (GameState.flags & gsScoreTimeout)
				if (gScoreDisplayTime != 0)
			    	if ((TimGetSeconds() - gScoreDisplayTime) > 2)
			        	ShowScore(0, NULL);


		handled = 1;
   		break;
	}
return handled;
}


static void SelectBlocks(Int32 x, Int32 y)
{
	Int16 total_size = 0;
    UnMarkAllBlocks();

	if (grid[y][x].value != DEAD_BLOCK) MarkTouchingBlocks(x, y, grid[y][x].value, &total_size, false);

	DrawGrid(false);

#ifndef ONE_BLOCK
    if (total_size > 1)
#endif
#ifdef ONE_BLOCK
    if (total_size > 0)
#endif
    {
        GameState.selected_blocks = (UInt8)total_size;
        GameState.possible_score = (total_size * (5+total_size));
        ShowScore(GameState.possible_score, "Possible:");
    }
}


//// Draw the grid - and do nothing to the grid variable
static void DrawGrid(Boolean update_only)
{
    Int x, y, i;

    for (y = GRID_Y_MIN; y < GRID_Y_MAX; y++)
        for (x = GRID_X_MIN; x < GRID_X_MAX; x++)
        {
	    	ScrOperation mode;
            Int ImageIndex = grid[y][x].value;

            // if the block is marked - paint the image inversed  //winPaintInverse
            // we need the update_only!=true - because updates do complete paints
            if ((grid[y][x].attributes & BLOCK_MARKED) && (grid[y][x].value != DEAD_BLOCK) && (update_only==false))
            {
	            mode = winMask;
                ImageIndex = MASK_BLOCK;
            }
            else
                mode = winPaint;

            // force dead blocks to do a full paint
			if (grid[y][x].value == DEAD_BLOCK) mode = winPaint;

            // draw the block
            DrawObject(ImageIndex, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), mode);

            // draw the mask over selected blocks if we're doing a complete redraw
            if ((update_only == true) && (grid[y][x].attributes & BLOCK_MARKED))
                DrawObject(MASK_BLOCK, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winMask);

        }
}

static void DrawObject(Int bitmapNumber, Short x, Short y, ScrOperation mode)
{
	RectangleType srcR;

	ErrFatalDisplayIf (ObjectWindowHandles[bitmapNumber] == 0, "Unhandled object image");

	// Copy the entire source window.
	MemMove (&srcR, &(ObjectWindowHandles[bitmapNumber]->windowBounds), sizeof(RectangleType));

	// Copy the source window (contains the image to draw) to the draw window.
	//WinCopyRectangle(ObjectWindowHandles[bitmapNumber], 0, &srcR, x, y, mode);
    WinCopyRectangle(ObjectWindowHandles[bitmapNumber], NULL, &srcR, x, y, mode);
}



static void RemoveMarkedBlocks(void)
{
    Int32 y,x;

    for (y = (GRID_Y_MAX-1); y >= GRID_Y_MIN; y-- )
        for (x = GRID_X_MIN; x < GRID_X_MAX; x++)
        	//only do marked blocks
            if (grid[y][x].attributes & BLOCK_MARKED)
            {
                MoveDeadBlockToTop(x, y, FindMarkedColumnLength(x, y));

				// unmark this block
		        UnMarkBlock(&grid[y][x].attributes);
			}


}


static UInt16 FindMarkedColumnLength(Int32 x, Int32 y1)
{
	UInt16 len = 0;
    Int32 y;

    for (y = y1; ((y >= GRID_Y_MIN) && (grid[y][x].attributes & BLOCK_MARKED)); y-- )
		len++;

    return len;
}

static void MoveDeadBlockToTop(Int32 x, Int32 y, UInt16 col_length)
{
	if (!IsValidCoord(x, y))
    {
        // do nothing - we're no longer in the grid
    }
    else if (IsValidCoord(x, y))
    {
#ifdef BLOCK_MOVE_DEBUG
    	Char a[8],b[8];
        StrIToA(a, y);StrIToA(b, y-col_length);
        FrmCustomAlert(altDebug, "swapping block a with b (y)", a, b);
#endif
        if (IsValidCoord(x, y-col_length))
        {
        	blockType tmp;

			// Swap the block
            MemMove(&tmp, &grid[y][x], sizeof(blockType));
            MemMove(&grid[y][x], &grid[y-col_length][x], sizeof(blockType));
			MemMove(&grid[y-col_length][x], &tmp, sizeof(blockType));


            // Remove the mark
            // x -= (x & C);
            // we do it like to be on the same side
            grid[y][x].attributes -= (grid[y][x].attributes & BLOCK_CHANGED);


            grid[y-col_length][x].value = DEAD_BLOCK;

            // mark the block above if it hasn't been marked already
            // safe side of adding a bit
            grid[y-1][x].attributes |= BLOCK_CHANGED;

            DrawObject(grid[y-col_length][x].value, (borderAroundScreen * x), ((borderAroundScreen * (y-col_length))+topBorderOffset), winPaint);
        }
        else
        	grid[y][x].value = DEAD_BLOCK;

        DrawObject(grid[y][x].value, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winPaint);

        // move up the column to swap blocks
        MoveDeadBlockToTop(x, y-1, col_length);
    }
    else if (!(grid[y][x].attributes & BLOCK_CHANGED))
    {
        // do nothing - we've not be marked to be removed
    }
    else if (!IsValidCoord(x, y-col_length))
    {
#ifdef BLOCK_MOVE_DEBUG
	    Char a[8],b[8];
        StrIToA(a, x);StrIToA(b, y);
        FrmCustomAlert(altDebug, "finalising (x,y)", a, b);
#endif

        DrawObject(grid[y][x].value, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winPaint);
    }
}

void UnMarkAllBlocks(void)
{
	UInt16 x,y;

	for (x = GRID_X_MIN; x < GRID_X_MAX; x++)
        for (y = GRID_Y_MIN; y < GRID_Y_MAX; y++)
            UnMarkBlock(&grid[y][x].attributes);

}

static void LockImage(int i, DmResID resId)
{
    Word error;

	ObjectBitmapHandles[i] = DmGetResource( 'Tbmp', resId);
    ObjectBitmapPtr[i] = MemHandleLock(ObjectBitmapHandles[i]);

    // It is actually faster and more versatile to store the graphics
    // as window images.  It is faster because WinDrawBitmap contructs a
    // window from the bitmap on the fly before drawing.  It is more
    // versatile because when the window is copied to the screen a
    // screen copy mode like scrCopyNot can be used.  This makes
    // images masks possible.
    // We can do this as long as their is enough memory free in the dynamic
    // ram.  We don't do this to large images.
    if (i == 999)           // don't skip any bitmaps we use
    {
        ObjectWindowHandles[i] = 0;
    }
    else
    {
        ObjectWindowHandles[i] = WinCreateOffscreenWindow(ObjectBitmapPtr[i]->width+1, ObjectBitmapPtr[i]->height+1, screenFormat, &error);
        ErrFatalDisplayIf(error, "Error loading images");
        WinSetDrawWindow(ObjectWindowHandles[i]);
        WinDrawBitmap(ObjectBitmapPtr[i], 0, 0);
    }
}

static void ReleaseLockedImage(int i)
{
    MemPtrUnlock(ObjectBitmapPtr[i]);
    DmReleaseResource(ObjectBitmapHandles[i]);

    if (ObjectWindowHandles[i])
        WinDeleteWindow(ObjectWindowHandles[i], false);
}

static Boolean CheckForBlankColumns(void)
{
    Int16 x,y;
    Boolean rc = false;

    // find the length of the verticle lines
 	for (x = GRID_X_MIN; x < GRID_X_MAX; x++ )
    {
    	col_lengths[x] = 0;
	 	for (y = GRID_Y_MIN; y < GRID_Y_MAX; y++ )
	        if (grid[y][x].value == DEAD_BLOCK)
            	col_lengths[x]++;

	}

    for (x = (GRID_X_MAX-1); x >= GRID_X_MIN; x-- )
        if (col_lengths[x] == GRID_Y_MAX)   // shift right columns to the left
        {
            rc = true;
            if (x == (GRID_X_MAX - 1))  // do something special if we are the far right - ie. nothing
            {
                // do nothing
            }
            else
            {
#ifdef SHIFT_DEBUG
                Char a[8], b[8];
                StrIToA(a, x);
                FrmCustomAlert(altDebug, "shifting row (x)", a, NULL);
#endif
                // doing it this way makes it look nice
			 	for (y = (GRID_Y_MAX-1); y >= GRID_Y_MIN; y-- )
                    ShiftRowLeft(x, y);
           }
        }

    return rc;
}

static void ShiftRowLeft(Int16 start_x, Int16 y)
{
    Int16 x;
#ifdef SHIFT_DEBUG
    Char a[8], b[8];
#endif

    for (x = start_x; x < GRID_X_MAX; x++ )
    {
        if (x == (GRID_X_MAX-1))
            grid[y][x].value = DEAD_BLOCK;
        else
			grid[y][x].value = grid[y][x+1].value;

            //grid[y][x].value = grid[y][x+1].value;
#ifdef SHIFT_DEBUG
        StrIToA(a, grid[y][x].value); StrIToA(b, x);
        FrmCustomAlert(altDebug, "shifting left (new val, x)", a, b);
#endif
        DrawObject(grid[y][x].value, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winPaint);
        if (x != (GRID_X_MAX-1)) DrawObject(grid[y][x+1].value, (borderAroundScreen * (x+1)), ((borderAroundScreen * y)+topBorderOffset), winPaint);
    }
}



/***********************************************************************
 *
 * FUNCTION:    HighScoresAddScore
 *
 * DESCRIPTION: Add the new score.
 *
 * PARAMETERS:  position - the position to add the score
 *					 name - name to add
 *					 score - score to add
 *					 dontAddIfExists - used when initializing scores
 *
 * RETURNED:    nothing
 *
 * REVISION HISTORY:
 *			Name	Date		Description
 *			----	----		-----------
 *			roger	3/13/96	Initial Revision
 *			roger	3/19/96	Broke out the check and contratulations dialog
 *
 ***********************************************************************/
static void HighScoresAddScore (CharPtr name, Long score, Boolean dontAddIfExists)
{
	int position;

	// Find where the score belongs.  The new score looses any ties.
	position = highScoreMax;
	while (position > 0 &&
		score > Prefs.high_score[position - 1].score)
		{
		position--;
		}


	// Leave if the score doesn't make it into the high scores.
	if (position >= highScoreMax)
		return;

	if (dontAddIfExists &&
		position > 0 &&
		StrCompare(name, Prefs.high_score[position - 1].name) == 0 &&
		score == Prefs.high_score[position - 1].score)
		return;

	// Move down the scores to make room for the new high score.
	MemMove(&Prefs.high_score[position + 1], &Prefs.high_score[position],
		(highScoreMax - 1 - position) * sizeof (SavedScore));


	Prefs.high_score[position].score = score;
	StrCopy(Prefs.high_score[position].name, name);


    // in future we'll need to do something much more clever
	Prefs.high_score[position].flags = GameState.current_level;


	// Record this new score as the last one entered.
	Prefs.last_high_score = position;

    // Record the random seed used to create this grid
    if (position == 0) //only for the top score
		Prefs.last_high_score_seed = GameState.last_random_seed;
}


/***********************************************************************
 *
 * FUNCTION:    HighScoresCheckScore
 *
 * DESCRIPTION: Check if the current score is a high one and call
 *	HighScoresAddScore if so.
 *
 * PARAMETERS:  score - score to possibly add
 *
 * RETURNED:    nothing
 *
 * REVISION HISTORY:
 *			Name	Date		Description
 *			----	----		-----------
 *			roger	3/13/96	Initial Revision
 *			roger	3/19/96	Broke into separate routine
 *			roger	4/23/96	Added a cancel button
 *
 ***********************************************************************/
static Boolean HighScoresCheckScore (Long score)
{
	int i;
	CharPtr nameP;
	Word buttonHit;
    Handle nameH;
	UInt32 romVersion;

	i = highScoreMax;
	while (i > 0 &&
		score > Prefs.high_score[i - 1].score)
		i--;


	// Leave if the score doesn't make it into the high scores.
	if (i >= highScoreMax)
		return false;


	// Allocate a chunk for the user to edit.  The field in the dialog requires
	// the text to be in a chunk so it can be resized.
	nameH = MemHandleNew(dlkMaxUserNameLength + 1);
    nameP = MemHandleLock(nameH);

    StrCopy(nameP, "");

    GetSyncName(nameP);

	if (gotVersion35)
    {
        Char namePTmp[nameLengthMax];
        // this isn't support in < 3.5
        FrmCustomResponseAlert(altGameState, "You got a high score, enter your name to the leaderboard (leave blank for default):", NULL, NULL, (CharPtr)(&namePTmp), nameLengthMax, NULL);
        if (namePTmp[0] != '\0')
            StrCopy(nameP, namePTmp);
    }

	MemPtrUnlock(nameP);

	// Record this new score as the last one entered.
	Prefs.last_high_score = i;

	// Add the score
    HighScoresAddScore(nameP, score, false);

	MemHandleFree(nameH);					// The name is now recorded and no longer needed

    return true;
}



void FindPossibleSets(void)
{
    Int32 x, y;

    GameState.remaining_blocks = 0;

    // by default say the game is over, until we find a valid block set
    GameState.game_active = false;

    // go from the bottom left
	for (x = (GRID_X_MAX-1); x >= GRID_X_MIN; x-- )
        for (y = (GRID_Y_MAX-1); y >= GRID_Y_MIN; y-- )
            if (grid[y][x].value != DEAD_BLOCK)
            {
                Boolean got_set = false;
                GameState.remaining_blocks += 1;

	            // left
	            if (!(x == GRID_X_MIN))  //LEFT_WALL
                    if (grid[y][x].value == grid[y][x-1].value) got_set = true;

	            // right
	            if (!(x == (GRID_X_MAX-1)))  // RIGHT_WALL
	                if (grid[y][x].value == grid[y][x+1].value) got_set = true;
	            // up
	            if (!(y == GRID_Y_MIN)) //  TOP_WALL
	                if (grid[y][x].value == grid[y-1][x].value) got_set = true;

	            // down
	            if (!(y == (GRID_Y_MAX-1)))  // BOTTOM_WALL
	                if (grid[y][x].value == grid[y+1][x].value) got_set = true;

				// if we've found any remaining sets - keep the game going
                // and quit the loop
				if (got_set == true)
                {
					GameState.game_active = true;
                    x = -1; y = -1;
                }
            }

    if ( (GameState.remaining_blocks == 0) && (GameState.game_active == false) )
	    GameState.score += 300;
    else if ((GameState.game_active == false) && (GameState.remaining_blocks <= 5))
    	GameState.score += 150;


}

static void CheckGameState(void)
{
	Char s[30];
    /*Char p[8];
    StrIToA(s, GameState.remaining_blocks);
	StrIToA(p, GameState.score);*/

    FindPossibleSets();

    // only 2 player games can go on to the second level
	if ( (GameState.game_type == gtSingleBasic) &&
		 (GameState.game_active == false) &&
		 (GameState.remaining_blocks == 0))
    {

        // play end of game noise
		SoundEffect(LowSweepHigh);

		// move on to the next level!
        GameState.current_level++;

        // This fucks the app
        //StrCopy(s, "Well done - you're on to level ");
        //StrIToA(level,GameState.current_level);
        //StrCat(s, level);

        // say they've moved to the next level
        // and reinitialise the board keeping their score
        FrmCustomAlert(altGameState, "Well done - you're on to the next level.", NULL, NULL);
	    InitGame(true);
    }
	else if (GameState.game_active == false)
    {
    	CharPtr msg;
        Handle memH;
        RectangleType rect;

        // play end of game noise
		SoundEffect(HighSweepLow);

        memH = MemHandleNew(sizeof(Char)*110);
		msg = MemHandleLock(memH);

        //FrmCustomAlert(altDebug, "remaining blocks, score", s, p);

        if (GameState.score < 650)
        	StrCopy(msg, "My God! You did REAL BAD!\nOnly ");
	    else if (GameState.score < 750)
        	StrCopy(msg, "Score was okay - could be better.\nOnly ");
	    else if (GameState.score < 950)
        	StrCopy(msg, "Not bad - for a loser.\nYou got ");
	    else if (GameState.score < 1200)
        	StrCopy(msg, "You're getting good..but aim higher.\nYou got ");
	    else if (GameState.score < 2000)
        	StrCopy(msg, "WOW! That was a good game.\nYou got ");
        else if (GameState.score < 5000)
        	StrCopy(msg, "Jeeze - excellent score.\nYou got ");
		else
        	StrCopy(msg, "EXCELLENT! I didn't know scores went that high!\nYou got ");

        StrIToA(s, GameState.score);
        StrCat(msg, s);
        StrCat(msg, " points");

        if (GameState.remaining_blocks == 0) StrCat(msg, "\n\nWith a bonus for clearing the grid.");
        else if (GameState.remaining_blocks <= 5) StrCat(msg, "\n\nWith a bonus for low remaining blocks.");

        MemPtrUnlock(msg);
        FrmCustomAlert(altGameState, msg, NULL, NULL);
        MemHandleFree(memH);

		// check high score...
        if (HighScoresCheckScore(GameState.score))
	        HighScoresDisplay ();


        // draw the game over box
		EndGameMessage();

        // make sure they can't undo the last go!
        GameState.undo_allowed = false;
    }
}


static void EndGameMessage(void)
{
    RectangleType rect;
    // draw the game over box

    // our box is going to be 70x25

    // top left location
    rect.topLeft.x = ((screenWidth / 2) - (85/2));  // 70
    rect.topLeft.y = 50;

    // dimensions
    rect.extent.x = 85; //70;
    rect.extent.y = 35; //25;

    WinSetPattern(&black);
    WinDrawRectangle(&rect, 5);

    rect.topLeft.x+=2;
    rect.topLeft.y+=2;
    rect.extent.x -= 4;
    rect.extent.y -= 4;

    WinSetPattern(&white);
    WinFillRectangle(&rect, 5);

    FntSetFont(7);

    // 9 = number of chars, then: topleftX, topleftY
    WinDrawChars ("Game Over", 9, rect.topLeft.x + 15, rect.topLeft.y + 3);
    FntSetFont(0);

    if ((GameState.game_type == gtMultiSame) && (GameState.current_player == player1))
    {
        WinDrawChars ("Player 2 tap here", 17, rect.topLeft.x + 4, rect.topLeft.y + 17);
    }
    else
        WinDrawChars ("Tap here to start", 17, rect.topLeft.x + 4, rect.topLeft.y + 17);

}



static void InitGame(Boolean keep_score)
{
	GameState.undo_allowed = false;

    UnMarkAllBlocks();

	if (GameState.game_active == false)
    {
	    GameState.game_active = true;
	    GameState.possible_score = 0;
	    GameState.remaining_blocks = 100;

        if ((keep_score != true) || (GameState.game_type == gtMultiSame))
        {
            GameState.score = 0;
            GameState.current_level = 1;
        }

        // if this is a two player game - and the last player was player 2...
        // set up a new two player game.
        if ((GameState.game_type == gtMultiSame) && (GameState.current_player == player1))
        {
			InitGrid();
            MemMove(&original_grid, &grid, sizeof(grid));

            // 0 = player 1
            GameState.current_player = player1;
		}
        // elsif - set the player as player 2
		else if ((GameState.game_type == gtMultiSame) && (GameState.current_player == player2))
        {
        	GameState.current_player = player2;
            MemMove(&grid, &original_grid, sizeof(grid));
        }
        else
        {
            InitGrid();
        }
    }

    DrawGrid(false);
}


/***********************************************************************
 *
 * FUNCTION:    HighScoresDisplay
 *
 * DESCRIPTION: Display the high score dialog
 *
 * PARAMETERS:  nothing
 *
 * RETURNED:    nothing
 *
 * REVISION HISTORY:
 *			Name	Date		Description
 *			----	----		-----------
 *			roger	3/11/96	Initial Revision
 *
 ***********************************************************************/
/*void HighScoresDisplay (void)
{
	char string[16];
	int i;
    CharPtr highScores;
    Handle nameH;

    // 25 = space needed for one high score
    // * 10 = showing 10 scores
    // + 25 = 5 for other bits + 20 for good will
	nameH = MemHandleNew((sizeof(Char)*(25*10))+25);
	highScores = MemHandleLock(nameH);

    // init the var (I found it was picking up junk)
    StrCopy(highScores, "");

	// Draw each high score in the right spot
	for (i = 0; i < highScoreMax && Prefs.high_score[i].score > 0; i++)
		{

		// Display the score number
		StrIToA(string, i + 1);
        StrCat(highScores, string);
		StrCat(highScores, ". ");

        StrCat(highScores, Prefs.high_score[i].name);
	    StrCat(highScores, " (");

        StrIToA(string, Prefs.high_score[i].score);

        StrCat(highScores, string);
        StrCat(highScores, ") ");

        if (i == Prefs.last_high_score) {
        	StrCat(highScores, " <<");
        }

        StrCat(highScores, "\n");
		}

	MemPtrUnlock(highScores);

    if (FrmCustomAlert(altHighScores, highScores, NULL, NULL) == 1) // clear the high scores;
        if (FrmCustomAlert (altConfirm, "Remove all but the first 3 high scores?", NULL, NULL) == 0)
	        ClearHighScores(3); // clear all scores lower than the 3rd score (ie. keep the high scores)

	MemHandleFree(nameH);					// The name is now recorded and no longer needed

} */

void HighScoresDisplay (void)
{
	FormPtr curFormP;
	FormPtr formP;
	MemHandle titleH;
	Char * titleP;
	char string[16];
	FontID currFont;
	int i;
	Int16 y;
	Char * winnerStringP;
	Char * heroStringP;


	curFormP = FrmGetActiveForm ();
	formP = FrmInitForm (frmGameResults);
	FrmSetActiveForm (formP);
	FrmDrawForm (formP);

	// Remember the font
	currFont = FntSetFont(boldFont);


	// Draw the titles of the columns
	titleH = MemHandleNew(sizeof(Char)*(5));
	titleP = MemHandleLock(titleH);
    StrCopy(titleP, "Name");
	WinDrawChars(titleP, StrLen(titleP), highScoreNameColumnX,
		firstHighScoreY - highScoreHeight);
    MemPtrUnlock(titleP);
    MemHandleFree(titleH);

	titleH = MemHandleNew(sizeof(Char)*(6));
	titleP = MemHandleLock(titleH);
    StrCopy(titleP, "Score");
	WinDrawChars(titleP, StrLen(titleP), highScoreScoreColumnX -
		FntCharsWidth(titleP, StrLen(titleP)), firstHighScoreY - highScoreHeight);
	MemPtrUnlock(titleP);
    MemHandleFree(titleH);

	titleH = MemHandleNew(sizeof(Char)*(7));
	titleP = MemHandleLock(titleH);
    StrCopy(titleP, "Level");
	WinDrawChars(titleP, StrLen(titleP), highScoreLevelColumnX -
		FntCharsWidth(titleP, StrLen(titleP)), firstHighScoreY - highScoreHeight);
	MemPtrUnlock(titleP);
    MemHandleFree(titleH);

	WinDrawLine(highScoreNameColumnX, firstHighScoreY - 1, highScoreLevelColumnX, firstHighScoreY - 1);
	// Draw each high score in the right spot
	for (i = 0; i < highScoreMax && Prefs.high_score[i].score > 0; i++)
		{
		y = firstHighScoreY + i * highScoreHeight;

		// Differentiate the last high score by choosing a different font.
		if (i == Prefs.last_high_score)
			FntSetFont(boldFont);
		else
			FntSetFont(highScoreFont);

		// Display the score number
		StrIToA(string, i + 1);
		StrCat(string, ". ");
		WinDrawChars(string, StrLen(string), highScoreNameColumnX -
			FntCharsWidth(string, StrLen(string)), y);

		WinDrawChars(Prefs.high_score[i].name, StrLen(Prefs.high_score[i].name),
			highScoreNameColumnX, y);

		StrIToA(string, Prefs.high_score[i].score);
		WinDrawChars(string, StrLen(string), highScoreScoreColumnX -
			FntCharsWidth(string, StrLen(string)), y);

		// The level is either a number or if they destroyed the homeworld
		// the level is a string.

        // 'Flags' in the future will also contain higher bits with flags
        // and the score in the lower bits - but for now we'll just use this.
		StrIToA(string, Prefs.high_score[i].flags);
		WinDrawChars(string, StrLen(string), highScoreLevelColumnX -
			FntCharsWidth(string, StrLen(string)), y);

		}
	FntSetFont(currFont);


	FrmDoDialog (formP);
	FrmDeleteForm (formP);
	FrmSetActiveForm (curFormP);
}



/***********************************************************************
 *
 * FUNCTION:    ShowScore
 *
 * DESCRIPTION: Displays a popup window in the top left with the score
 *              prefixed with a string
 *
 * PARAMETERS:  score, prefix string
 *
 * RETURNED:    nothing
 *
 * REVISION HISTORY:
 *			Name	Date		Description
 *			----	----		-----------
 *			remy	3/10/02		Initial Revision
 *
 ***********************************************************************/
void ShowScore(Int32 score, CharPtr prefix_str)
{
    RectangleType bounds;
    Char s[6];
    CharPtr string;
    FormPtr frmP = FrmGetActiveForm();
    UInt16 gadgetIndex = FrmGetObjectIndex(frmP, gdtScore);

    if (prefix_str != NULL)
    {
        Handle nameH;
        UInt16 x_offset = 0;

        gScoreDisplayed = true;
        gScoreDisplayTime = TimGetSeconds();

		nameH = MemHandleNew(sizeof(Char)*17);
        string = MemHandleLock(nameH);

        // "Possible: 321"
        // "Score: 3215"
        StrCopy(string, prefix_str);

        FrmShowObject(frmP, gadgetIndex);

	    //As an example of custom drawing we will
	    //draw a rectangle boundary around the gadget
	    FrmGetObjectBounds(frmP, gadgetIndex, &bounds);

	    WinDrawRectangleFrame(popupFrame, &bounds);

        //WinSetPatternType(blackPattern);
        WinSetPattern(&white);
		WinFillRectangle(&bounds, 0);

	    //WinSetPattern(&whitePat);

	    StrIToA(s, score);

        if (StrLen(s) < 4) StrCat(string, " ");

	    StrCat(string, s);

        // centre the text a bit so it looks nice
        // 13 is the top length
        x_offset = (13 - StrLen(string)) + 2;

        MemPtrUnlock(string);
	    WinDrawChars (string, StrLen(string), bounds.topLeft.x+x_offset, bounds.topLeft.y + 1);
        MemHandleFree(nameH);
    }
    else
    {
        Int16 x,y;

		gScoreDisplayed = false;
        gScoreDisplayTime = 0;


	    //As an example of custom drawing we will
	    //draw a rectangle boundary around the gadget
	    FrmGetObjectBounds(frmP, gadgetIndex, &bounds);

        // check to see if we need to redraw the top right four boxes that
        // we covered by the gadget

        // get the x,y index based on the top left of the gadget
        // this is so we don't have to change the code if we ever have
        // smaller blocks (ie. it's not the top right four)
        AlignPointsToBlock(&bounds.topLeft.x, &bounds.topLeft.y);

        y = bounds.topLeft.y;

        // hide the gadget before we start redrawing
		FrmHideObject(frmP, gadgetIndex);

		for (x = bounds.topLeft.x; x < GRID_X_MAX; x++ )
        {
            DrawObject(grid[y][x].value, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winPaint );

            // draw the mask if the block has been marked
            if (grid[y][x].attributes & BLOCK_MARKED)
                DrawObject(MASK_BLOCK, (borderAroundScreen * x), ((borderAroundScreen * y)+topBorderOffset), winMask );

            DrawObject(grid[y+1][x].value, (borderAroundScreen * x), ((borderAroundScreen * (y+1))+topBorderOffset), winPaint);

            // draw the mask if the block has been marked
            if (grid[y+1][x].attributes & BLOCK_MARKED)
                DrawObject(MASK_BLOCK, (borderAroundScreen * x), ((borderAroundScreen * (y+1))+topBorderOffset), winMask );
        }
    }
}


void ClearHighScores(Int16 start_from)
{

    UInt16 i;

    if (start_from == NULL) start_from = 0;

    for (i = start_from; i < highScoreMax; i++)
        {
        Prefs.high_score[i].name[0] = '\0';
        Prefs.high_score[i].score = 0;
        }
}

void UndoMove(void)
{

	if (GameState.undo_allowed == true)
    {
		GameState.undo_allowed = false;

		// copy the undo struct over the grid
		MemMove(&grid, &undo_grid, sizeof(grid));
	    UnMarkAllBlocks();
	    DrawGrid(false);

	    // subtract the score
	    GameState.score -= last_possible_score;
        last_possible_score = 0;

	    ShowScore(GameState.score, "Score:");
	}
    else
     	FrmCustomAlert(altGameState, "No more undos allowed.", NULL, NULL);
}

void SendHighScores(void)
{
    if (Prefs.high_score[0].score != 0)
    {
        CharPtr scoresP;
        CharPtr nameP;
        Char s[10];
		Handle scoresH;
        UInt32 checksum = 0;
        UInt32 checksum2 = 0;
		UInt8 i;
        VoidHand hResource;        // Generic Handle to resource





		/*curFormP = FrmGetActiveForm ();
		formP = FrmInitForm (frmGameResults);
		FrmSetActiveForm (formP);
		FrmDrawForm (formP);

		// Remember the font
		//currFont = FntSetFont(boldFont);


		// Draw the titles of the columns
		titleH = MemHandleNew(sizeof(Char)*(100));
		titleP = MemHandleLock(titleH);
	    StrCopy(titleP, "Send the following details in an email");
		WinDrawChars(titleP, StrLen(titleP), 4, 19);
	    //MemPtrUnlock(titleP);
	    //MemHandleFree(titleH);

		//titleH = MemHandleNew(sizeof(Char)*(34));
		//titleP = MemHandleLock(titleH);
	    StrCopy(titleP, "to palm@ihatemusic.com with your");
		WinDrawChars(titleP, StrLen(titleP), 4, 32);
		//MemPtrUnlock(titleP);
	    //MemHandleFree(titleH);

		//titleH = MemHandleNew(sizeof(Char)*(42));
		//titleP = MemHandleLock(titleH);
	    StrCopy(titleP, "name and country and I'll put you on the");
		WinDrawChars(titleP, StrLen(titleP), 4, 46);
		//MemPtrUnlock(titleP);
	    //MemHandleFree(titleH);

	    StrCopy(titleP, "the leader board.");
		WinDrawChars(titleP, StrLen(titleP), 4, 59);

	    StrCopy(titleP, "Check out www.ihatemusic.com for");
		WinDrawChars(titleP, StrLen(titleP), 4, 76);

	    StrCopy(titleP, "the World's best Marbles\262 players.");
		WinDrawChars(titleP, StrLen(titleP), 4, 89);        */


        // work out the game code
        scoresH = MemHandleNew(130 + nameLengthMax + 12 + 3 + 6 + 10);  // name, score, checksum, grid seed
    	scoresP = MemHandleLock(scoresH);

        StrCopy(scoresP, "");

        StrCat(scoresP, "Send the following details in an email to palm@ihatemusic.com with your name and country and I'll put you on the leader board.\n\n");
        StrCat(scoresP, Prefs.high_score[0].name);
        StrIToA(s, Prefs.high_score[0].score);

        StrCat(scoresP, "-");
        StrCat(scoresP, s);
        StrCat(scoresP, "-");

        if((hResource = DmGet1Resource('tver', 1)) != 0)
        {
            CharPtr charP = (CharPtr) MemHandleLock(hResource);
			StrCat(scoresP, charP);      // actuall get the version from the resource
            MemPtrUnlock(charP);
            DmReleaseResource(hResource);
            //return(true);
        }
        else
        {

		}

        // add the level
        StrIToA(s, Prefs.high_score[0].flags);
        StrCat(scoresP, s);

        // add the grid seed
        StrIToH(s, Prefs.last_high_score_seed);
		StrCat(scoresP, "\n");
        StrCat(scoresP, s);


        StrCat(scoresP, "-");
        checksum = GetCheckSum(scoresP);

        checksum %= 3246;

		StrIToA(s, checksum);
        StrCat(scoresP, s);

        checksum2 = GetCheckSum(scoresP);
        checksum2 += checksum;

        StrIToA(s, checksum2);

        // take the last number from the final
        // checksum and add it to the end
        i = StrLen(s)-1;

        StrCat(scoresP, &s[i]);

		MemPtrUnlock(scoresP);
	    FrmCustomAlert(altGameState, scoresP, NULL, NULL);
		MemHandleFree(scoresH);


		//MemPtrUnlock(titleP);
	    //MemHandleFree(titleH);

    }
    else
    {
        FrmCustomAlert(altGameState, "No high scores to send.", NULL, NULL);
    }
}

UInt32 GetCheckSum(CharPtr text)
{
    UInt8 i;
    UInt32 checksum = 0;

    for (i = 0; i < StrLen(text); i++)
    {
    	char c = (char)*(text+i);
        checksum = (checksum + ((int)c));
    }

    return checksum;
 }

void GetSyncName(CharPtr nameP)
{
	CharPtr firstSpaceP;

	// Try and use the user's name
    DlkGetSyncInfo(NULL, NULL, NULL, nameP, NULL, NULL);

    // Just use the first name
    firstSpaceP = StrChr(nameP, spaceChr);
    if (firstSpaceP)
        *firstSpaceP = '\0';

    // Truncate the string to insure it's not too long
    nameP[nameLengthMax] = '\0';
}

void ShowMultiGameBreakDown(void)
{
    Handle stringH;
    CharPtr string;

    UInt8 x = 64;
    UInt8 y = 41;
    UInt8 i;
    UInt8 cur_player = 0;
    FormPtr formP, curFormP;
    UInt8 total_players = (GameState.game_type == gtMultiSame) ? 2 : 1;

    curFormP = FrmGetActiveForm ();
	formP    = FrmInitForm (frmGameResults);
	FrmSetActiveForm (formP);
	FrmDrawForm (formP);


    stringH = MemHandleNew(sizeof(Char)*500);
    string = MemHandleLock(stringH);

	// who won??? / is winning
    if (GameState.game_type == gtMultiSame)
    {
		if (player[0].score > player[1].score)
	    {
	        if (GameState.game_active == true)
	            StrCopy(string, "   Player 1 is winning.");
			else
				StrCopy(string, "Player 1 won the game.");
	    }
	    else if (player[0].score < player[1].score)
	    {
	        if (GameState.game_active == true)
	            StrCopy(string, "   Player 2 is winning.");
	        else
		        StrCopy(string, "Player 2 won the game.");
	    }
	    else
	    {
			StrCopy(string, "    The game is a tie.");
	    }
    }
    else
		StrCopy(string, "Player score breakdown.");

    FntSetFont(1);  // bold
	WinDrawChars(string, StrLen(string), 23,15);
    MemPtrUnlock(string);
    MemHandleFree(stringH);

    WinDrawLine (4, 27, 152, 27);
    WinDrawChars("P1", 2, 64, 30);

    if (GameState.game_type == gtMultiSame)
		WinDrawChars("P2", 2, 104, 30);
    FntSetFont(0);  // standard

    WinDrawChars("Score:", 6, 4, y+(0*12));
    WinDrawChars("Biggest set:", 12, 4, y+(1*12));
    WinDrawChars("20+ blocks:", 11, 4, y+(2*12));
    WinDrawChars("10-19 blocks:", 13, 4, y+(3*12));
    WinDrawChars("5-9 blocks:", 11, 4, y+(4*12));
    WinDrawChars("4 blocks:", 9, 4, y+(5*12));
    WinDrawChars("3 blocks:", 9, 4, y+(6*12));
	WinDrawChars("2 blocks:", 9, 4, y+(7*12));


    // show player break down - makes it possible for more than
    // two players...
    for (i = 0; i < total_players; i++)
    {
        char var[10];

        // score
        FntSetFont(GetWinnersFont(player[0].score, player[1].score, i));
        StrIToA(var, player[i].score);
        WinDrawChars(var, StrLen(var), x, y+(0*12));

        // biggest set
		FntSetFont(GetWinnersFont(player[0].best_set, player[1].best_set, i));
        StrIToA(var, player[i].best_set);
        WinDrawChars(var, StrLen(var), x, y+(1*12));

        // set info
		FntSetFont(GetWinnersFont(player[0].found_sets[5], player[1].found_sets[5], i));
        StrIToA(var, player[i].found_sets[5]);
        WinDrawChars(var, StrLen(var), x, y+(2*12));

		FntSetFont(GetWinnersFont(player[0].found_sets[4], player[1].found_sets[4], i));
        StrIToA(var, player[i].found_sets[4]);
        WinDrawChars(var, StrLen(var), x, y+(3*12));

  		FntSetFont(GetWinnersFont(player[0].found_sets[3], player[1].found_sets[3], i));
        StrIToA(var, player[i].found_sets[3]);
        WinDrawChars(var, StrLen(var), x, y+(4*12));

        FntSetFont(GetWinnersFont(player[0].found_sets[2], player[1].found_sets[2], i));
        StrIToA(var, player[i].found_sets[2]);
        WinDrawChars(var, StrLen(var), x, y+(5*12));

        FntSetFont(GetWinnersFont(player[0].found_sets[1], player[1].found_sets[1], i));
        StrIToA(var, player[i].found_sets[1]);
        WinDrawChars(var, StrLen(var), x, y+(6*12));

        FntSetFont(GetWinnersFont(player[0].found_sets[0], player[1].found_sets[0], i));
        StrIToA(var, player[i].found_sets[0]);
        WinDrawChars(var, StrLen(var), x, y+(7*12));

        x = 104;

 	}

    FntSetFont(0);

    // clean up
	FrmDoDialog (formP);
	FrmDeleteForm (formP);
	FrmSetActiveForm (curFormP);

}

FontID GetWinnersFont(Int16 val_p1, Int16 val_p2, UInt8 current_player)
{
    FontID font = 0;

    if (current_player == player1)    // player 1
    {
        if (val_p1 > val_p2)
            font = 1;
    }
    else
        if (val_p2 > val_p1)
            font = 1;


    return font;
}


void ResetMultiPlayerScores(void)
{
    UInt8 i, j;

    for (i = 0; i < 2; i++)
    {
        player[i].best_set = 0;
        player[i].score = 0;
        player[i].game_length = 0;

	    for (j = 0; j < 6; j++)
            player[i].found_sets[j] = 0;
	}

    //ShowMultiGameBreakDown();
}

void NewGame(UInt8 current_player, Boolean resume, UInt32 seed)
{
    MenuEraseStatus(NULL);  // this clears the popup command before we redraw

    if (GameState.game_type == gtMultiSame)
        NewTwoPlayerGame(current_player, seed);
    else // if (GameState.game_type == gtSingleBasic)
        NewOnePlayerGame(resume, seed);
}

void NewTwoPlayerGame(UInt8 current_player, UInt32 seed)
{
    // declare the previous game as ended
	GameState.game_active = false;

    // hack to make the game begin correctly
    GameState.current_player = current_player;

    GameState.game_type = gtMultiSame;

    if (seed)
    {
        randomSeed = seed;
        GameState.last_random_seed = randomSeed;
    }
    else if (GameState.current_player == player1)
    {
    	randomSeed = GetGameSeed();
        GameState.last_random_seed = randomSeed;
    }

    // reinitialise the board
    InitGame(NULL);

    // let player one know it's their turn
    if (GameState.current_player == player1)
    {
        ResetMultiPlayerScores();      // zero all the multiplayer scores - if this is a new game
	    FrmCustomAlert(altGameState, "Player 1 - your turn...", NULL, NULL);
    }
}

void NewOnePlayerGame(Boolean resume, UInt32 seed) // supports resuming of game state
{
    // declare the previous game as ended
	if (resume != true)
    {
		GameState.game_active = false;

		// if we passed a random seed - then play this board
	    if (seed)
	    {
	        randomSeed = seed;
	        GameState.last_random_seed = randomSeed;
	    }
	    else
	    {
	        randomSeed = GetGameSeed();
	        GameState.last_random_seed = randomSeed;
	    }

    }

    GameState.game_type = gtSingleBasic;

    ResetMultiPlayerScores();

    GameState.current_player = player1;

    // reinitialise the board
    InitGame(NULL);
}

void NewSeededGame(UInt32 seed)
{
    if (seed)
    {
        FrmCustomAlert(altGameState, "For more game 'seeds' go to the web site www.ihatemusic.com and challenge the high scoring players on the leader board!", NULL, NULL);
        NewOnePlayerGame(false, seed);
    }
    else
    {
        FrmCustomAlert(altGameState, "You did not specify a game seed - you can get these from the www.ihatemusic.com web site and challenge the high scores on the web site!", NULL, NULL);
    }
}


UInt32 hex2bin(const char *hex)
{
    UInt32 i, j;
    j = 0;
    while(*hex) {
        j <<= 4;
        if((i = (UInt32) *hex++ - '0') > 9)
            i -= 7;
        j |= i & 95;
    } return j;
}

UInt32 GetGameSeed(void)
{
    //return RandN(TimGetSeconds(), 0xfffff);
	return TimGetSeconds();
}


void SoundEffect(Int16 effect)
{
   SndCommandType    s;

	if (!(GameState.flags & gsSound))
        return;

    s.cmd = sndCmdFreqDurationAmp;
    s.param3 = GameVolume;              // amplitude
    if (effect == HighBeep)
    {
	    s.param1 = 4000;                    // frequency
	    s.param2 = 20;                      // duration (in ms)
	    SndDoCmd(0, &s, 0);
    }
    else if (effect == LowBeep)
    {
	    s.param1 = 150;
	    s.param2 = 20;
	    SndDoCmd(0, &s, 0);
    }
    else if (effect == HighSweepLow)
    {
	    s.param2 = 3;
	    for (s.param1 = 3000; s.param1 >=500; s.param1 -= 50)
	      SndDoCmd(0, &s, 0);
    }
    else if (effect == LowSweepHigh)
    {
	    s.param2 = 3;
	    for (s.param1 = 1000; s.param1 <=5000; s.param1 += 100)
	      SndDoCmd(0, &s, 0);
    }
}

Boolean GetCtrlValue(UInt16 objectID)
{
     ControlType *ctl;
     FormType *form;

     form = FrmGetActiveForm();
     ctl = FrmGetObjectPtr(form, FrmGetObjectIndex(form, objectID));

     return (Boolean) CtlGetValue(ctl);
}

